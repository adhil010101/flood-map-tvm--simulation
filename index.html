<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flood Alert — Trivandrum (Road-avoidance)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  :root{
    --bg:#0f1720; --panel:#0b1220; --text:#e6eef6; --muted:#9fb0c8;
    --accent:#16a34a; --danger:#ef4444; --safe:#28c76f; --alt:#a3e635;
  }
  body.light{ --bg:#f6fbff; --panel:#fff; --text:#0b1220; --muted:#475569; }
  *{box-sizing:border-box}
  html,body,#map{height:100%;margin:0;padding:0}
  body{font-family:Inter,Segoe UI,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text)}

  /* main left panel */
  #leftPanel{ position:absolute; left:12px; top:12px; z-index:1500; width:360px; background:var(--panel); padding:12px; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.45); }
  #leftPanel h3{ margin:0 0 8px 0; font-size:16px }
  .input{ width:100%; padding:10px; margin-bottom:8px; border-radius:8px; border:0; background:#071025; color:var(--text) }
  .btn{ width:100%; padding:10px; border-radius:8px; border:0; cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,0.35); }
  #findBtn{ background: linear-gradient(90deg,#10b981,#064e3b); font-weight:700; color:#fff }
  .small{ font-size:12px; color:var(--muted) }

  /* suggestions under inputs */
  .suggestions{ position:absolute; z-index:2100; background:var(--panel); border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.45); overflow:auto; max-height:220px; color:var(--text) }
  .suggestions div{ padding:8px; border-bottom:1px solid rgba(255,255,255,0.03); cursor:pointer }
  .suggestions div:hover{ background: rgba(255,255,255,0.02) }

  /* map-top controls */
  #topControls{ position:absolute; right:12px; top:12px; z-index:1550; display:flex; flex-direction:column; gap:8px; align-items:flex-end }
  .smallBtn{ padding:8px 10px; border-radius:8px; border:0; background:#071025; color:var(--text); cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,0.35) }

  /* legend and weather */
  #legend{ position:absolute; left:12px; bottom:12px; z-index:1200; background:var(--panel); padding:10px; border-radius:10px; color:var(--muted); font-size:13px }
  #weatherBadge{ background:var(--panel); padding:8px; border-radius:8px; color:var(--muted) }

  /* alert banner */
  #alertBanner{ position:absolute; left:50%; transform:translateX(-50%); top:12px; z-index:1600; min-width:320px; padding:12px; border-radius:10px; display:none; font-weight:700; color:white; cursor:pointer; box-shadow:0 12px 40px rgba(0,0,0,0.4) }

  /* modals */
  .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:1700; background:rgba(0,0,0,0.45) }
  .panel{ width:560px; max-height:82vh; overflow:auto; background:var(--panel); padding:14px; border-radius:12px; color:var(--text) }
  textarea.input{ height:120px; }

  /* map overlay finish button */
  #mapFinishBtn{ position:absolute; left:50%; transform:translateX(-50%); bottom:100px; z-index:2000; display:none; padding:10px 14px; border-radius:10px; background:var(--accent); color:#04311a; font-weight:700; cursor:pointer; box-shadow:0 12px 30px rgba(2,6,23,0.6) }

  @media (max-width:720px){ #leftPanel{ width:92%; left:4% } .panel{ width:90% } }
</style>
</head>
<body>
  <div id="alertBanner"></div>

  <div id="leftPanel">
    <h3>Flood Alert — Trivandrum</h3>

    <label class="small">Start (type or "Current location")</label>
    <div style="display:flex;gap:8px">
      <input id="startInput" class="input" placeholder="Type start or 'Current location'">
      <button id="useCurrentBtn" class="smallBtn">Current</button>
    </div>
    <div id="startSuggest" class="suggestions" style="display:none"></div>

    <label class="small">Destination (Trivandrum)</label>
    <input id="endInput" class="input" placeholder="Type destination">
    <div id="endSuggest" class="suggestions" style="display:none"></div>

    <div style="display:flex;gap:8px">
      <button id="findBtn" class="btn">Find fast & safe route</button>
      <button id="takeSafeBtn" class="btn" style="display:none;background:var(--safe);color:#04311a">Take Safe Route</button>
    </div>

    <div id="routeInfo" class="small"></div>

    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="reportBtn" class="smallBtn" style="background:var(--danger)">Report Flood Road</button>
      <button id="openSettingsBtn" class="smallBtn">Settings</button>
    </div>
  </div>

  <div id="topControls">
    <div id="weatherBadge" class="small" style="display:none"></div>
  </div>

  <div id="legend">
    <div style="margin-bottom:6px"><strong>Legend</strong></div>
    <div style="display:flex;gap:8px;align-items:center"><div style="width:18px;height:10px;background:var(--danger)"></div><div class="small">Flooded road</div></div>
    <div style="display:flex;gap:8px;align-items:center"><div style="width:18px;height:10px;background:var(--safe)"></div><div class="small">Safe route</div></div>
  </div>

  <div id="map"></div>

  <button id="mapFinishBtn">Finish Report</button>

  <!-- Report modal -->
  <div id="reportModal" class="modal">
    <div class="panel">
      <h3 style="margin-top:0">Report Flooded Road — Pick on Map</h3>
      <p class="small">Click <b>Pick on Map</b>, then click START and END on map. After picking two points, the map shows a Finish button. You can also paste two coords:</p>
      <input id="reportInput" class="input" placeholder="Optional: lat1,lng1;lat2,lng2">
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="pickRoadBtn" class="smallBtn">Pick on Map</button>
        <button id="closeReportBtn" class="smallBtn" style="background:#b91c1c">Close</button>
      </div>
    </div>
  </div>

  <!-- Settings & Admin modal -->
  <div id="settingsModal" class="modal">
    <div class="panel">
      <h3 style="margin-top:0">Settings & Admin</h3>

      <div style="display:flex;gap:8px;margin-bottom:8px">
        <button id="toggleThemeBtn" class="smallBtn">Toggle Light/Dark</button>
        <button id="resetViewBtn" class="smallBtn">Reset View</button>
      </div>

      <hr/>

      <h4>Admin Login</h4>
      <input id="adminUser" class="input" placeholder="Admin id (default: admin)">
      <input id="adminPass" class="input" placeholder="Password" type="password">
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="adminLoginBtn" class="smallBtn" style="background:var(--accent)">Login</button>
        <button id="adminChangePassBtn" class="smallBtn">Change Password</button>
        <button id="closeSettingsBtn" class="smallBtn" style="background:#b91c1c">Close</button>
      </div>

      <div id="adminTools" style="display:none;margin-top:12px">
        <h4>Pending Reports</h4>
        <div id="reportsList" style="max-height:160px;overflow:auto"></div>

        <hr/>
        <h4>Draw Flooded Road (Admin)</h4>
        <p class="small">Start Draw → click map points → Finish & Save</p>
        <div style="display:flex;gap:8px;margin-bottom:8px">
          <button id="startDrawBtn" class="smallBtn">Start Draw</button>
          <button id="finishDrawBtn" class="smallBtn" style="background:var(--accent)">Finish & Save</button>
          <button id="cancelDrawBtn" class="smallBtn" style="background:#b91c1c">Cancel</button>
        </div>

        <hr/>
        <h4>Export / Import Flooded Roads</h4>
        <div style="display:flex;gap:8px;margin-bottom:8px">
          <button id="exportBtn" class="smallBtn">Export</button>
          <button id="importBtn" class="smallBtn">Import</button>
        </div>
        <textarea id="importArea" class="input" placeholder='Paste JSON array of roads: [{"coords":[[lat,lng],[lat,lng],...]}, ...]'></textarea>

        <hr/>
        <div id="roadsList" style="max-height:160px;overflow:auto"></div>
      </div>
    </div>
  </div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.polylinedecorator/1.7.0/leaflet.polylineDecorator.min.js"></script>

<script>
/* ========== CONFIG ========== */
const GRAPH_HOPPER_KEY = '363c2df2-baa1-4e35-b1b9-9ceb7fc3eed1';
const ORS_KEY = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImViOTBkMjI4ZGUyNDRkMzg5MGU1ZWVkNjU0MDU0Y2MzIiwiaCI6Im11cm11cjY0In0=';
const OWM_KEY = 'ce70bf8bdb2bbf3ad192ee196735d6cf';
const VIEWBOX = '76.7,8.7,77.2,8.3';

/* ========== MAP INIT ========== */
const bounds = L.latLngBounds([8.3,76.7],[8.7,77.2]);
const map = L.map('map',{minZoom:11,maxZoom:18,maxBounds:bounds}).setView([8.5241,76.9366],13);
const baseTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);
const darkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',{maxZoom:19});
if(OWM_KEY) L.tileLayer(`https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=${OWM_KEY}`,{opacity:0.6}).addTo(map);

/* ========== STORAGE (IndexedDB) ========== */
function openDB(name='floodDB', version=1){
  return new Promise((resolve,reject)=>{
    const rq = indexedDB.open(name, version);
    rq.onupgradeneeded = (ev)=>{
      const db = ev.target.result;
      if(!db.objectStoreNames.contains('roads')) db.createObjectStore('roads',{keyPath:'id'});
      if(!db.objectStoreNames.contains('reports')) db.createObjectStore('reports',{keyPath:'id'});
      if(!db.objectStoreNames.contains('meta')) db.createObjectStore('meta',{keyPath:'k'});
    };
    rq.onsuccess = ()=> resolve(rq.result);
    rq.onerror = ()=> reject(rq.error);
  });
}
async function put(store, obj){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(store,'readwrite'); const os = tx.objectStore(store); const r = os.put(obj); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error); }); }
async function add(store, obj){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(store,'readwrite'); const os = tx.objectStore(store); const r = os.add(obj); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error); }); }
async function del(store, key){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(store,'readwrite'); const os = tx.objectStore(store); const r = os.delete(key); r.onsuccess = ()=> res(); r.onerror = ()=> rej(r.error); }); }
async function all(store){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(store,'readonly'); const os = tx.objectStore(store); const r = os.getAll(); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error); }); }
async function getMeta(k){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction('meta','readonly'); const os = tx.objectStore('meta'); const r = os.get(k); r.onsuccess = ()=> res(r.result ? r.result.v : null); r.onerror = ()=> rej(r.error); }); }
async function setMeta(k,v){ return put('meta', { k, v }); }

/* ========== UTIL ========== */
function genId(){ return 'id'+Math.random().toString(36).slice(2,9); }
function showBanner(text, onclick){ const b = document.getElementById('alertBanner'); b.style.display='block'; b.style.background='linear-gradient(90deg,#ef4444,#f43f5e)'; b.innerText = text; if(onclick){ b.style.cursor='pointer'; b.onclick = ()=>{ onclick(); b.style.display='none'; } } setTimeout(()=>{ try{ b.style.display='none'; }catch(e){} },9000); }
function hideBanner(){ const b=document.getElementById('alertBanner'); b.style.display='none'; b.onclick=null; }

/* ========== SUGGESTIONS (Nominatim bounded) ========== */
async function nominatim(q){
  try{
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&limit=6&viewbox=${VIEWBOX}&bounded=1`;
    const r = await fetch(url, { headers:{ 'Accept-Language':'en' }});
    if(!r.ok) return [];
    return await r.json();
  }catch(e){ console.warn(e); return []; }
}
function positionSuggest(inputEl, boxEl){
  const r = inputEl.getBoundingClientRect();
  boxEl.style.left = (r.left + window.scrollX) + 'px';
  boxEl.style.top = (r.bottom + window.scrollY + 6) + 'px';
  boxEl.style.width = r.width + 'px';
}
function attachSuggest(inputEl, boxEl){
  let t=null; inputEl.addEventListener('input', ()=>{ clearTimeout(t); const q=inputEl.value.trim(); if(!q){ boxEl.style.display='none'; boxEl.innerHTML=''; return; } t=setTimeout(async ()=>{ const res=await nominatim(q); boxEl.innerHTML=''; if(!res || res.length===0){ const d=document.createElement('div'); d.innerText='No results (Trivandrum)'; d.style.color='var(--muted)'; boxEl.appendChild(d); } else { res.forEach(it=>{ const div=document.createElement('div'); div.innerText=it.display_name; div.onclick=()=>{ inputEl.value=it.display_name; inputEl._latlng=[parseFloat(it.lat), parseFloat(it.lon)]; boxEl.style.display='none'; boxEl.innerHTML=''; }; boxEl.appendChild(div); }); } positionSuggest(inputEl, boxEl); boxEl.style.display='block'; },300); });
  inputEl.addEventListener('blur', ()=>{ setTimeout(()=>{ boxEl.style.display='none'; },220); });
  window.addEventListener('resize', ()=>{ if(boxEl.style.display==='block') positionSuggest(inputEl, boxEl); });
  window.addEventListener('scroll', ()=>{ if(boxEl.style.display==='block') positionSuggest(inputEl, boxEl); });
}
attachSuggest(document.getElementById('startInput'), document.getElementById('startSuggest'));
attachSuggest(document.getElementById('endInput'), document.getElementById('endSuggest'));

/* ========== CURRENT LOCATION & WEATHER ========== */
let userPos=null, userMarker=null;
if(navigator.geolocation){
  navigator.geolocation.watchPosition(p=>{
    userPos=[p.coords.latitude,p.coords.longitude];
    if(!userMarker) userMarker = L.circleMarker(userPos,{radius:8,fillColor:'#06b6d4',color:'#fff',weight:2}).addTo(map).bindPopup('You are here');
    else userMarker.setLatLng(userPos);
    // weather
    fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${userPos[0]}&lon=${userPos[1]}&appid=${OWM_KEY}&units=metric`)
      .then(r=>r.json()).then(w=>{ const badge=document.getElementById('weatherBadge'); badge.style.display='block'; const rain=(w.rain && w.rain['1h'])?` · Rain(1h): ${w.rain['1h']}mm` : ''; badge.innerHTML=`<b>Weather</b><br>${w.main.temp}°C · Hum ${w.main.humidity}%${rain}`; }).catch(()=>{});
  }, e=>{ console.warn('geo err', e); }, { enableHighAccuracy:true, maximumAge:5000 });
}

/* ========== ROUTING (GH + ORS fallback + ORS avoidance using polygons) ========== */
async function ghRoute(points){
  // points: [[lat,lng],...]
  const base = 'https://graphhopper.com/api/1/route';
  const p = new URLSearchParams();
  points.forEach(pt=> p.append('point', `${pt[0]},${pt[1]}`));
  p.set('vehicle','car'); p.set('points_encoded','false'); p.set('instructions','false'); p.set('key', GRAPH_HOPPER_KEY);
  const url = base + '?' + p.toString();
  const r = await fetch(url);
  if(!r.ok) throw new Error('GH:'+r.status);
  return r.json();
}
async function orsRoute(points, avoidMultipolygon=null){
  const base = 'https://api.openrouteservice.org/v2/directions/driving-car/geojson';
  const coords = points.map(pt=>[pt[1],pt[0]]); // lon,lat
  const body = { coordinates: coords };
  if(avoidMultipolygon) body.avoid_polygons = avoidMultipolygon;
  const r = await fetch(base, { method:'POST', headers:{ 'Authorization': ORS_KEY, 'Content-Type':'application/json' }, body: JSON.stringify(body) });
  if(!r.ok) { const txt = await r.text(); throw new Error('ORS:'+r.status+' '+txt); }
  return r.json();
}

/* ========== FLOODED ROADS STORAGE & RENDER ========== */
let roadsCache = [], roadLayers = {};
async function loadRoads(){ roadsCache = await all('roads') || []; renderRoads(); renderRoadsList(); }
function renderRoads(){
  // clear
  Object.values(roadLayers).forEach(l=>{ try{ map.removeLayer(l);}catch(e){} });
  roadLayers = {};
  roadsCache.forEach(r=>{
    const poly = L.polyline(r.coords, { color: 'var(--danger)', weight:5, dashArray:'8,8' }).addTo(map);
    poly.bindPopup('Flooded road (admin)');
    roadLayers[r.id]=poly;
  });
}
function renderRoadsList(){
  const c = document.getElementById('roadsList'); if(!c) return;
  c.innerHTML='';
  roadsCache.forEach(r=>{
    const div=document.createElement('div'); div.style.padding='8px'; div.style.borderBottom='1px solid rgba(255,255,255,0.03)';
    div.innerHTML = `<b>Road</b> ${r.coords.length} pts`;
    const rm=document.createElement('button'); rm.className='smallBtn'; rm.style.float='right'; rm.style.background='#b91c1c'; rm.innerText='Remove';
    rm.onclick = async ()=>{ await del('roads', r.id); await loadRoads(); alert('Removed'); };
    div.appendChild(rm); c.appendChild(div);
  });
}

/* ========== HELPER GEOMETRY ========== */
// point-to-segment distance (m)
function pointToSegmentDistance(pt, A, B){
  const lat1=A[0]*Math.PI/180, lon1=A[1]*Math.PI/180;
  const lat2=B[0]*Math.PI/180, lon2=B[1]*Math.PI/180;
  const lat3=pt[0]*Math.PI/180, lon3=pt[1]*Math.PI/180;
  const R=6371000;
  const x1=R*lon1*Math.cos(lat1), y1=R*lat1;
  const x2=R*lon2*Math.cos(lat2), y2=R*lat2;
  const x3=R*lon3*Math.cos(lat3), y3=R*lat3;
  const dx=x2-x1, dy=y2-y1;
  if(dx===0 && dy===0) return Math.hypot(x3-x1,y3-y1);
  const t = ((x3-x1)*dx + (y3-y1)*dy) / (dx*dx + dy*dy);
  const tt = Math.max(0, Math.min(1, t));
  const xc = x1 + dx*tt, yc = y1 + dy*tt;
  return Math.hypot(x3-xc, y3-yc);
}
// haversine
function haversine(lat1,lon1,lat2,lon2){ const R=6371000; const toRad=Math.PI/180; const dLat=(lat2-lat1)*toRad; const dLon=(lon2-lon1)*toRad; const a=Math.sin(dLat/2)**2 + Math.cos(lat1*toRad)*Math.cos(lat2*toRad)*Math.sin(dLon/2)**2; return 2*R*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)); }

/* create avoid MultiPolygon from flooded roads by buffering each point into small circular polygons and combining */
function circleToPolygon(center, radiusMeters=25, steps=16){
  const lat=center[0], lon=center[1];
  const R=6378137;
  const coords=[];
  for(let i=0;i<steps;i++){
    const brng = (i*(360/steps))*Math.PI/180;
    const lat2 = Math.asin(Math.sin(lat*Math.PI/180)*Math.cos(radiusMeters/R) + Math.cos(lat*Math.PI/180)*Math.sin(radiusMeters/R)*Math.cos(brng));
    const lon2 = (lon*Math.PI/180) + Math.atan2(Math.sin(brng)*Math.sin(radiusMeters/R)*Math.cos(lat*Math.PI/180), Math.cos(radiusMeters/R)-Math.sin(lat*Math.PI/180)*Math.sin(lat2));
    coords.push([ lon2*180/Math.PI, lat2*180/Math.PI ]);
  }
  coords.push(coords[0]);
  return [coords];
}
function roadToMultipolygon(road, buffer=25){
  // combine buffers around each vertex into a MultiPolygon where each polygon is a circle-to-polygon around each vertex
  return {
    type: "MultiPolygon",
    coordinates: road.coords.map(pt => circleToPolygon(pt, buffer, 12))
  };
}

/* ========== ROUTE CALC & AVOIDANCE ========== */
let mainRouteLayer=null, mainDash=null, altRouteLayer=null, altDash=null, floodedSegmentsLayers=[];

function clearRouteGraphics(){
  if(mainRouteLayer) try{ map.removeLayer(mainRouteLayer);}catch(e){} mainRouteLayer=null;
  if(altRouteLayer) try{ map.removeLayer(altRouteLayer);}catch(e){} altRouteLayer=null;
  floodedSegmentsLayers.forEach(l=>{ try{ map.removeLayer(l);}catch(e){} });
  floodedSegmentsLayers=[];
  hideBanner();
  document.getElementById('takeSafeBtn').style.display='none';
  document.getElementById('routeInfo').innerText='';
}
function animateDash(layer, speed=90){
  let off=0; const id=setInterval(()=>{ off=(off+1)%100; try{ layer.setStyle({ dashOffset:String(off) }); }catch(e){} }, speed); layer._ani=id; return id;
}
function drawAnimatedPolyline(points, opts){
  const pl = L.polyline(points, opts).addTo(map);
  pl._ani = animateDash(pl, 90);
  return pl;
}
function decorateArrows(poly, color){
  try{ return L.polylineDecorator(poly, { patterns:[{ offset:'6%', repeat:'10%', symbol: L.Symbol.arrowHead({ pixelSize:10, polygon:false, pathOptions:{ stroke:true, weight:2, color } }) }] }).addTo(map); } catch(e){ return null; }
}

/* detect route intersections with flooded roads */
function detectFloodHitsOnRoute(routeCoords){
  const hits=[];
  roadsCache.forEach(road=>{
    let seg=null;
    routeCoords.forEach(pt=>{
      let near=false;
      for(let j=0;j<road.coords.length-1;j++){
        const a=road.coords[j], b=road.coords[j+1];
        if(pointToSegmentDistance(pt,a,b) < 25){ near=true; break; }
      }
      if(near){ if(!seg) seg=[]; seg.push(pt); } else { if(seg){ hits.push({road, seg}); seg=null; } }
    });
    if(seg) hits.push({road, seg});
  });
  return hits;
}

/* calculate & show route (tries GH then ORS for main, uses ORS avoid_polygons for alternate) */
async function calculateAndShow(){
  try{
    clearRouteGraphics();
    showBanner('Loading route — please wait...');
    const sVal=document.getElementById('startInput').value.trim();
    const eVal=document.getElementById('endInput').value.trim();
    if(!sVal || !eVal){ alert('Enter start & destination'); hideBanner(); return; }
    const start = await resolvePlace(sVal, document.getElementById('startInput'));
    const dest = await resolvePlace(eVal, document.getElementById('endInput'));
    if(!start || !dest){ alert('Could not resolve places'); hideBanner(); return; }

    // try GraphHopper for main route (fast)
    let mainRes=null, coords=[];
    try { mainRes = await ghRoute([start,dest]); if(mainRes.paths && mainRes.paths.length>0){ coords = mainRes.paths[0].points.coordinates.map(c=>[c[1],c[0]]); document.getElementById('routeInfo').innerText = `Main: ${(mainRes.paths[0].distance/1000).toFixed(2)} km · ${(mainRes.paths[0].time/60000).toFixed(1)} min`; } }
    catch(e){ console.warn('GH main failed, try ORS', e); try{ const ors = await orsRoute([start,dest]); coords = ors.features[0].geometry.coordinates.map(c=>[c[1],c[0]]); const sum = ors.features[0].properties.summary || {}; document.getElementById('routeInfo').innerText = `Main: ${(sum.distance/1000||0).toFixed(2)} km · ${((sum.duration||0)/60).toFixed(1)} min`; } catch(err){ console.error('Both routing failed', err); alert('Route fetch failed — check keys & network (console).'); hideBanner(); return; } }

    // draw main
    mainRouteLayer = L.polyline(coords, { color:'#1e40af', weight:6 }).addTo(map);
    decorateArrows(mainRouteLayer,'#1e40af');
    mainRouteLayer._dash = animateDash(mainRouteLayer,120);
    map.fitBounds(mainRouteLayer.getBounds(), { padding:[80,80] });

    // detect flooded segments
    const hits = detectFloodHitsOnRoute(coords);
    if(hits.length>0){
      // mark flooded portions red dashed
      hits.forEach(h=>{
        const l = drawAnimatedPolyline(h.seg, { color: 'var(--danger)', weight:6, dashArray:'10,8' });
        floodedSegmentsLayers.push(l);
      });
      // auto generate alternative: use ORS avoid polygons built from flooded roads
      showBanner('⚠️ Flooded road detected on route — click here for safe alternate', ()=> {
        generateSafeAlternate(coords, start, dest);
      });
      document.getElementById('takeSafeBtn').style.display='inline-block';
      document.getElementById('takeSafeBtn').onclick = ()=> generateSafeAlternate(coords, start, dest);
    } else {
      document.getElementById('routeInfo').innerText += ' · No flooded roads on route';
      hideBanner();
    }
  }catch(e){ console.error(e); alert('Route calculation error'); hideBanner(); }
}

/* build avoid multipolygon by buffering each road (create circles at points) */
function buildAvoidMultipolygonFromRoads(roadArray){
  // roadArray: array of road objects, each has coords[[lat,lng],...]
  const multi = { type:'MultiPolygon', coordinates: [] };
  roadArray.forEach(r=>{
    r.coords.forEach(pt=>{
      const poly = circleToPolygon(pt, 35, 14); // buffer ~35m
      multi.coordinates.push(poly[0]);
    });
  });
  return multi;
}

/* circleToPolygon: same as earlier */
function circleToPolygon(center, radiusMeters=35, steps=16){
  const lat=center[0], lon=center[1];
  const R=6378137;
  const coords=[];
  for(let i=0;i<steps;i++){
    const brng = (i*(360/steps))*Math.PI/180;
    const lat2 = Math.asin(Math.sin(lat*Math.PI/180)*Math.cos(radiusMeters/R) + Math.cos(lat*Math.PI/180)*Math.sin(radiusMeters/R)*Math.cos(brng));
    const lon2 = (lon*Math.PI/180) + Math.atan2(Math.sin(brng)*Math.sin(radiusMeters/R)*Math.cos(lat*Math.PI/180), Math.cos(radiusMeters/R)-Math.sin(lat*Math.PI/180)*Math.sin(lat2));
    coords.push([ lon2*180/Math.PI, lat2*180/Math.PI ]);
  }
  coords.push(coords[0]);
  return [coords];
}

/* generate safe alternate using ORS avoid_polygons and fallback to GH detour */
async function generateSafeAlternate(routeCoords, start, dest){
  try{
    showBanner('Generating safe alternate — please wait...');
    // take all flooded roads that intersect the main route
    const hits = detectFloodHitsOnRoute(routeCoords);
    const affectedRoads = Array.from(new Set(hits.map(h=>h.road.id))).map(id => roadsCache.find(r=>r.id===id));
    // build avoid multipolygon
    const avoidMulti = buildAvoidMultipolygonFromRoads(affectedRoads);
    // try ORS with avoid_polygons
    try{
      const or = await orsRoute([start,dest], avoidMulti);
      // draw alt route
      const altcoords = or.features[0].geometry.coordinates.map(c=>[c[1],c[0]]);
      if(altRouteLayer) try{ map.removeLayer(altRouteLayer);}catch(e){}
      altRouteLayer = L.polyline(altcoords, { color: getComputedStyle(document.documentElement).getPropertyValue('--safe').trim()||'#28c76f', weight:6 }).addTo(map);
      decorateArrows(altRouteLayer, getComputedStyle(document.documentElement).getPropertyValue('--safe').trim()||'#28c76f');
      altRouteLayer._dash = animateDash(altRouteLayer, 100);
      map.fitBounds(altRouteLayer.getBounds(), { padding:[80,80] });
      document.getElementById('routeInfo').innerText += ' · Safe alternate (avoiding flooded road) shown';
      hideBanner();
      document.getElementById('takeSafeBtn').onclick = ()=> { // apply safe route: remove main route visuals but keep flooded markers
        if(mainRouteLayer) try{ map.removeLayer(mainRouteLayer);}catch(e){} mainRouteLayer=null;
        if(altRouteLayer) altRouteLayer.setStyle({ color: '#16a34a', weight:7 });
        hideBanner();
      };
      return;
    }catch(e){
      console.warn('ORS avoid failed: ', e);
      // fallback: use GH with detour point near hit (left/right)
      const hit = hits[0];
      const mid = hit.seg[Math.floor(hit.seg.length/2)];
      const offsetMeters = 220;
      const lat = mid[0]*Math.PI/180, lon = mid[1]*Math.PI/180;
      const dLat = (offsetMeters/111000);
      const left = [ mid[0] + dLat, mid[1] - dLat ];
      const right = [ mid[0] - dLat, mid[1] + dLat ];
      const cand = [ [start, left, dest], [start, right, dest] ];
      let best = null;
      for(const pts of cand){
        try{
          const g = await ghRoute(pts);
          if(g.paths && g.paths.length>0){
            const coords = g.paths[0].points.coordinates.map(c=>[c[1],c[0]]);
            const time = g.paths[0].time;
            if(!best || time < best.time) best = { coords, time };
          }
        }catch(e2){ console.warn('GH detour failed', e2); }
      }
      if(best){
        if(altRouteLayer) try{ map.removeLayer(altRouteLayer);}catch(e){}
        altRouteLayer = L.polyline(best.coords, { color:getComputedStyle(document.documentElement).getPropertyValue('--safe').trim()||'#28c76f', weight:6 }).addTo(map);
        altRouteLayer._dash = animateDash(altRouteLayer, 100);
        decorateArrows(altRouteLayer, getComputedStyle(document.documentElement).getPropertyValue('--safe').trim()||'#28c76f');
        map.fitBounds(altRouteLayer.getBounds(), { padding:[80,80] });
        document.getElementById('routeInfo').innerText += ' · Safe alternate (detour) shown';
        hideBanner();
        return;
      }
      throw new Error('No alternate found');
    }
  }catch(e){ console.error('generateSafeAlternate err', e); alert('Could not generate safe alternate'); hideBanner(); }
}

/* ========== USER REPORT FLOW (pick on map) ========== */
let reportPickMode=false; let reportPoints=[]; let tempPreview=null;
document.getElementById('reportBtn').addEventListener('click', ()=>{ document.getElementById('reportModal').style.display='flex'; reportPickMode=false; reportPoints=[]; clearTempPreview(); });
document.getElementById('closeReportBtn').addEventListener('click', ()=>{ document.getElementById('reportModal').style.display='none'; reportPickMode=false; reportPoints=[]; clearTempPreview(); });
document.getElementById('pickRoadBtn').addEventListener('click', ()=>{ // hide modal and activate picking
  document.getElementById('reportModal').style.display='none';
  reportPickMode = true; reportPoints=[]; clearTempPreview();
  alert('Pick START then END on the map (two clicks). After second click, a "Finish Report" button will appear.');
  // focus map center
  map.invalidateSize();
});
map.on('click', async function(e){
  if(reportPickMode){
    if(reportPoints.length === 0){
      reportPoints[0] = [e.latlng.lat, e.latlng.lng];
      tempPreview = L.marker(reportPoints[0]).addTo(map);
      alert('Start set. Click END point.');
    } else if(reportPoints.length === 1){
      reportPoints[1] = [e.latlng.lat, e.latlng.lng];
      if(tempPreview) try{ map.removeLayer(tempPreview);}catch(e){} tempPreview = L.polyline(reportPoints, { color:'#f97316', weight:4, dashArray:'6,6' }).addTo(map);
      reportPickMode = false;
      document.getElementById('mapFinishBtn').style.display='block';
      alert('END set. Click Finish Report to submit.');
    }
  }

  // admin drawing mode handled later
});

/* Finish report button behavior */
document.getElementById('mapFinishBtn').addEventListener('click', async ()=>{
  // parse input or use reportPoints
  const val = document.getElementById('reportInput').value.trim();
  let coords = null;
  if(val){
    const parts = val.split(';').map(s=>s.trim()).filter(Boolean);
    if(parts.length>=2){
      coords = parts.slice(0,2).map(p=>{
        const m = p.match(/(-?\d+(\.\d+)?)\s*[,;]\s*(-?\d+(\.\d+)?)/);
        return [parseFloat(m[1]), parseFloat(m[3])];
      });
    }
  }
  if(!coords && reportPoints.length===2) coords = reportPoints.slice();
  if(!coords || coords.length<2){ alert('Select points or paste coords first'); return; }
  const rep = { id: genId(), type:'road', coords, text:'user-report', time: Date.now(), status:'pending' };
  await add('reports', rep);
  alert('Report submitted to admin for review.');
  document.getElementById('mapFinishBtn').style.display='none';
  clearTempPreview();
});

/* helper clear preview */
function clearTempPreview(){ if(tempPreview) try{ map.removeLayer(tempPreview);}catch(e){} tempPreview=null; reportPoints=[]; reportPickMode=false; document.getElementById('mapFinishBtn').style.display='none'; document.getElementById('reportInput').value=''; }

/* ========== ADMIN (secure client-side) ========== */
/* default admin preset hashing */
const DEFAULT_ADMIN = 'admin';
const DEFAULT_PW = 'StrongP@ssw0rd!'; // strong default
async function sha256Hex(str){
  const enc = new TextEncoder().encode(str);
  const hash = await crypto.subtle.digest('SHA-256', enc);
  return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function ensureAdminHash(){
  let storedHash = await getMeta('adminHash');
  if(!storedHash){
    const hashed = await sha256Hex(DEFAULT_PW + '::SALTv1');
    await setMeta('adminHash', hashed);
  }
}
async function checkAdminLogin(user, pass){
  const storedHash = await getMeta('adminHash');
  if(!storedHash) return false;
  const h = await sha256Hex(pass + '::SALTv1');
  return (user === 'admin' && h === storedHash);
}
async function changeAdminPassword(newPass){
  const h = await sha256Hex(newPass + '::SALTv1'); await setMeta('adminHash', h);
}

/* admin login wiring */
document.getElementById('adminLoginBtn').addEventListener('click', async ()=>{
  const u = document.getElementById('adminUser').value.trim() || 'admin';
  const p = document.getElementById('adminPass').value;
  const ok = await checkAdminLogin(u,p);
  if(ok){
    document.getElementById('adminTools').style.display='block';
    await refreshAdminLists();
    alert('Admin logged in');
  } else alert('Wrong credentials');
});
document.getElementById('adminChangePassBtn').addEventListener('click', async ()=>{
  const cur = prompt('Enter current admin password:');
  if(!cur) return;
  const ok = await checkAdminLogin('admin', cur);
  if(!ok){ alert('Current password wrong'); return; }
  const nw = prompt('Enter new strong password:');
  if(!nw || nw.length < 8){ alert('Password too short (min 8)'); return; }
  await changeAdminPassword(nw); alert('Admin password changed');
});

/* ========== ADMIN: reports preview & approve ========== */
async function refreshAdminLists(){
  const reps = await all('reports') || [];
  const list = document.getElementById('reportsList');
  list.innerHTML='';
  if(reps.length===0) list.innerHTML = '<div class="small">No pending reports</div>';
  reps.forEach(r=>{
    if(r.status && r.status!=='pending') return;
    const div = document.createElement('div'); div.style.padding='8px'; div.style.borderBottom='1px solid rgba(255,255,255,0.03)';
    div.innerHTML = `<b>Road report</b><br><small>${new Date(r.time).toLocaleString()}</small>`;
    const preview = document.createElement('button'); preview.className='smallBtn'; preview.style.marginLeft='8px'; preview.innerText='Preview';
    preview.onclick = ()=> { if(window._preview) try{ map.removeLayer(window._preview);}catch(e){} window._preview = L.polyline(r.coords, { color:'#f97316', weight:5, dashArray:'6,6' }).addTo(map); map.fitBounds(window._preview.getBounds(), { padding:[60,60] }); };
    const approve = document.createElement('button'); approve.className='smallBtn'; approve.style.marginLeft='8px'; approve.style.background='var(--accent)'; approve.innerText='Approve';
    approve.onclick = async ()=> { await add('roads', { id: genId(), coords: r.coords }); await del('reports', r.id); await loadRoads(); await refreshAdminLists(); alert('Approved and saved'); };
    const reject = document.createElement('button'); reject.className='smallBtn'; reject.style.marginLeft='8px'; reject.style.background='#b91c1c'; reject.innerText='Reject';
    reject.onclick = async ()=> { await del('reports', r.id); await refreshAdminLists(); alert('Rejected'); };
    div.appendChild(preview); div.appendChild(approve); div.appendChild(reject);
    list.appendChild(div);
  });
}

/* ========== ADMIN draw roads ========== */
let adminDrawing=false, adminDrawPts=[], adminDrawPreview=null;
document.getElementById('startDrawBtn').addEventListener('click', ()=>{ adminDrawing=true; adminDrawPts=[]; alert('Click on map to add draw points (admin). Then click Finish & Save.'); });
document.getElementById('finishDrawBtn').addEventListener('click', async ()=>{ if(adminDrawPts.length<2){ alert('Need >=2 points'); return; } await add('roads', { id: genId(), coords: adminDrawPts.slice() }); adminDrawing=false; if(adminDrawPreview) try{ map.removeLayer(adminDrawPreview);}catch(e){} adminDrawPreview=null; await loadRoads(); alert('Saved flooded road'); });
document.getElementById('cancelDrawBtn').addEventListener('click', ()=>{ adminDrawing=false; adminDrawPts=[]; if(adminDrawPreview) try{ map.removeLayer(adminDrawPreview);}catch(e){} adminDrawPreview=null; alert('Canceled'); });
map.on('click', function(e){
  if(adminDrawing){ adminDrawPts.push([e.latlng.lat, e.latlng.lng]); if(adminDrawPreview) try{ map.removeLayer(adminDrawPreview);}catch(e){} adminDrawPreview = L.polyline(adminDrawPts, { color:'#ef4444', weight:4, dashArray:'8,8' }).addTo(map); }
});

/* ========== EXPORT/IMPORT ========== */
document.getElementById('exportBtn').addEventListener('click', async ()=>{ const roads = await all('roads'); document.getElementById('importArea').value = JSON.stringify(roads, null, 2); alert('Exported JSON below'); });
document.getElementById('importBtn').addEventListener('click', async ()=>{ const txt = document.getElementById('importArea').value.trim(); if(!txt) return alert('Paste JSON'); try{ const arr = JSON.parse(txt); if(!Array.isArray(arr)) return alert('Invalid JSON'); for(const r of arr){ if(r.coords) await add('roads', { id: genId(), coords:r.coords }); } await loadRoads(); alert('Imported'); }catch(e){ alert('Import error: '+e.message); } });

/* ========== HELPERS: resolvePlace & event wiring ========== */
async function resolvePlace(text, inputEl){
  if(!text) return null;
  if(text.toLowerCase().includes('current') && userPos) return userPos;
  if(inputEl && inputEl._latlng) return inputEl._latlng;
  const m = text.match(/(-?\d+(\.\d+)?)\s*[,;]\s*(-?\d+(\.\d+)?)/);
  if(m) return [parseFloat(m[1]), parseFloat(m[3])];
  const res = await nominatim(text);
  if(res && res.length>0) return [parseFloat(res[0].lat), parseFloat(res[0].lon)];
  return null;
}

/* event wiring */
document.getElementById('useCurrentBtn').addEventListener('click', ()=>{ if(userPos){ document.getElementById('startInput').value='Current location'; document.getElementById('startInput')._latlng = userPos; } else alert('Allow location permission'); });
document.getElementById('findBtn').addEventListener('click', calculateAndShow);
document.getElementById('openSettingsBtn').addEventListener('click', ()=>{ document.getElementById('settingsModal').style.display='flex'; });
document.getElementById('closeSettingsBtn').addEventListener('click', ()=>{ document.getElementById('settingsModal').style.display='none'; });
document.getElementById('toggleThemeBtn').addEventListener('click', ()=>{ document.body.classList.toggle('light'); if(document.body.classList.contains('light')){ if(map.hasLayer(darkTiles)) map.removeLayer(darkTiles); baseTiles.addTo(map); } else { if(map.hasLayer(baseTiles)) map.removeLayer(baseTiles); darkTiles.addTo(map); } });

/* initialize DB, demo roads, UI */
async function seedDemoRoadsOnce(){
  const roads = await all('roads');
  if(roads && roads.length>0) return;
  // 10 demo small roads (hardcoded approximate)
  const demo = [
    { id: genId(), coords:[[8.5280,76.9350],[8.5285,76.9370]] },
    { id: genId(), coords:[[8.5150,76.9550],[8.5160,76.9560]] },
    { id: genId(), coords:[[8.5030,76.9300],[8.5045,76.9315]] },
    { id: genId(), coords:[[8.5440,76.9000],[8.5430,76.9020]] },
    { id: genId(), coords:[[8.4900,76.9800],[8.4920,76.9815]] },
    { id: genId(), coords:[[8.5350,76.9200],[8.5335,76.9220]] },
    { id: genId(), coords:[[8.5170,76.9200],[8.5185,76.9215]] },
    { id: genId(), coords:[[8.5600,76.8900],[8.5585,76.8920]] },
    { id: genId(), coords:[[8.4950,76.9470],[8.4965,76.9485]] },
    { id: genId(), coords:[[8.5020,76.9650],[8.5035,76.9660]] }
  ];
  for(const d of demo) await add('roads', d);
}

/* startup */
(async function init(){
  await openDB();
  await ensureAdminHash();
  await seedDemoRoadsOnce();
  await loadRoads();
  await refreshAdminLists();
  // position suggestions initial
  setTimeout(()=>{ positionSuggest(document.getElementById('startInput'), document.getElementById('startSuggest')); positionSuggest(document.getElementById('endInput'), document.getElementById('endSuggest')); }, 300);
})();

</script>
</body>
</html>
